### **Vulnerability Assessment Report: com.snake**

**1. Executive Summary**
*   The application implements a subscription/key model (“Snake Engine / Snake Seller”) where access/entitlement state is handled on the client side (Flutter) and persisted via plaintext `SharedPreferences` writes from the Android host (`com.Entry`). Because there is **no integrity protection** around these stored values, a user can **modify local state to force “UNLOCKED”/subscription activation** and access paid functionality without paying.

**2. Vulnerability Details: Client-Side Entitlement Enforcement via Plaintext SharedPreferences (Subscription/Key Bypass)**
*   **Severity:** High
*   **CWE:** CWE-345: Insufficient Verification of Data Authenticity; CWE-602: Client-Side Enforcement of Server-Side Security
*   **Affected Component(s):**
    *   **File Path:** `/workspace/jadx_out/sources/com/Entry.java`
    *   **Class:** `com.Entry`
    *   **Method:** `C(fd0 fd0Var, hd0.d dVar)` (Flutter↔Android bridge handler)
    *   **Line(s):** `74-93` (writes/reads arbitrary keys to `SharedPreferences`)

    *   **File Path:** `/workspace/jadx_out/resources/lib/arm64-v8a/libapp.so`
    *   **Class:** N/A (Flutter AOT)
    *   **Method:** N/A (compiled Dart)
    *   **Line(s):** N/A (binary) — includes entitlement-related constants such as `"UNLOCKED"` (extractable via `strings`), indicating a client-side unlock state.

*   **Attack Path Narrative (Source-to-Sink):**
    *   **Hypothesis:** The app enforces paid entitlements (subscription/key unlock) using client-side state persisted locally (e.g., `"UNLOCKED"`), rather than a server-verified entitlement token.
    *   **Data Source (attacker-controlled):** Local `SharedPreferences` storage for the app (`/data/data/com.snake/shared_prefs/<package>.xml`), which can be modified on a rooted device / emulator, or via instrumentation (Frida) during runtime.
    *   **Data Flow (evidence of client-side persistence):**
        *   In `com.Entry.C(...)`, action `"B"` takes a `Map` and writes every key/value pair directly into `SharedPreferences` under the app package name (no signing/HMAC, no encryption).
        *   Action `"D"` reads arbitrary preference keys and returns them to Flutter.
        *   This bridge strongly indicates the Flutter layer persists and consumes security-relevant state via these plaintext preferences.
    *   **Sink (entitlement decision):** The Flutter app (compiled into `libapp.so`) contains entitlement markers like `"UNLOCKED"` and subscription UX (“Get Subscription”, “Keys were created successfully”), consistent with **local gating** based on stored values. If the UI/feature gating checks only this local state, modifying it results in “paid” access without a valid purchase/subscription.

*   **Proof-of-Concept:**
    *   **Option A — File-level tampering (rooted device/emulator):**

```bash
# 1) Start app once to create prefs
adb shell run-as com.snake ls -la /data/data/com.snake/shared_prefs

# 2) Pull prefs XML (if debuggable/run-as works) or use root/emulator
adb shell su -c 'cat /data/data/com.snake/shared_prefs/com.snake.xml' > com.snake.xml

# 3) Edit and inject an entitlement flag (example key seen in Flutter binary strings)
# <string name="UNLOCKED">true</string>

# 4) Push back and relaunch
adb push com.snake.xml /sdcard/com.snake.xml
adb shell su -c 'cp /sdcard/com.snake.xml /data/data/com.snake/shared_prefs/com.snake.xml && chmod 660 /data/data/com.snake/shared_prefs/com.snake.xml && chown u0_a*/u0_a* /data/data/com.snake/shared_prefs/com.snake.xml'
adb shell am force-stop com.snake
adb shell monkey -p com.snake 1
```

    *   **Option B — Runtime tampering (Frida):** Hook `SharedPreferences.Editor.putString()` / `putBoolean()` and force-write the unlock/subscription keys before the entitlement check runs.

*   **Remediation Guidance:**
    *   Enforce entitlements **server-side** (or via Play Billing purchase token verification on the server) and treat the client as untrusted.
    *   If offline state must exist:
        *   Store only **opaque, short-lived** entitlement tokens and validate them cryptographically (e.g., signed by backend) before granting access.
        *   Use **integrity protection** for local state (HMAC with a key in Android Keystore; detect tampering).
        *   Avoid designing unlock logic around simple boolean/string flags (e.g., `"UNLOCKED"`) that can be trivially flipped.

