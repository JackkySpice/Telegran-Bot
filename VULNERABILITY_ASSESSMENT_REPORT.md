### **Vulnerability Assessment Report: com.snake**

**1. Executive Summary**
*   The app implements a subscription/key model (“Snake Engine / Snake Seller”). During this pass I **confirmed** that the Flutter layer can **read/write arbitrary key/value pairs** into plaintext Android `SharedPreferences` via a custom Flutter↔Android bridge (`com.Entry`, channel `"A"`, methods `"B"` and `"D"`).  
*   However, based on static evidence alone, I **cannot yet confirm** that flipping any locally stored value results in **real “free keys / unpaid entitlement”** being honored by the backend (i.e., not just UI changes). Additional runtime validation is required before claiming a bug-bounty-eligible “free keys” bypass.

**2. Vulnerability Details: Untrusted Local State Used for Key/Subscription Logic (Needs Runtime Confirmation)**
*   **Severity:** High (if the backend trusts this state); otherwise Not Applicable
*   **CWE:** CWE-345: Insufficient Verification of Data Authenticity; CWE-602: Client-Side Enforcement of Server-Side Security
*   **Affected Component(s):**
    *   **File Path:** `/workspace/jadx_out/sources/com/Entry.java`
    *   **Class:** `com.Entry`
    *   **Method:** `C(fd0 fd0Var, hd0.d dVar)` (Flutter↔Android bridge handler)
    *   **Line(s):** `74-93` (writes/reads arbitrary keys to `SharedPreferences`)

    *   **File Path:** `/workspace/blutter_out/pp.txt`
    *   **Class:** Flutter `MethodChannel`
    *   **Method:** N/A (object pool evidence)
    *   **Line(s):** `10822-10828` (channel name `"A"`), `10826-10827` (method `"D"` nearby), `12601` (method `"B"` string)

*   **Attack Path Narrative (Source-to-Sink):**
    *   **Confirmed data source:** Flutter can instruct the Android host to persist arbitrary strings into `SharedPreferences` via `com.Entry`:
        *   `"B"` branch: takes a `Map` and writes each entry as `SharedPreferences.putString(key,value)`.
        *   `"D"` branch: reads arbitrary keys via `SharedPreferences.getString(key,"")` and returns them to Flutter.
    *   **Confirmed bridge existence (Flutter side):** A `MethodChannel` object exists with name `"A"` in the Flutter object pool (`/workspace/blutter_out/pp.txt` lines `10822-10825`), matching the channel string used by the Android host (`Entry.h = "A"`).
    *   **Hypothesis (needs confirmation):** If the key/subscription entitlement checks rely on these locally persisted values, then a user could tamper the stored values (root/emulator/instrumentation) to unlock key creation/activation without paying.
    *   **Why it’s not yet a confirmed vulnerability:** The backend endpoint `https://rest.snakeseller.com/api/request/` is present in the app (`/workspace/blutter_out/pp.txt` line `16522`) and appears to enforce authentication (observed in live probes). Without proving that a local-state flip leads to successful server-side key issuance/activation, this remains a hypothesis.

*   **Proof-of-Concept:**
    *   **Validation-only PoC (safe, non-destructive):** Demonstrates local-state tampering mechanics. This does **not** by itself prove “free keys” unless you observe real entitlement/key issuance after the tamper.

```bash
adb shell su -c 'cat /data/data/com.snake/shared_prefs/com.snake.xml' > com.snake.xml
# edit com.snake.xml (keep valid XML), then:
adb push com.snake.xml /sdcard/com.snake.xml
adb shell su -c 'cp /sdcard/com.snake.xml /data/data/com.snake/shared_prefs/com.snake.xml && chmod 660 /data/data/com.snake/shared_prefs/com.snake.xml'
adb shell am force-stop com.snake
adb shell monkey -p com.snake 1
```

    *   **Runtime confirmation criteria (required to claim “free keys”):**
        *   After tampering, the app must be able to **create/activate keys** in a way that is **accepted by the backend** (e.g., key appears in account inventory, activates on another device, or enables server-gated features).

*   **Remediation Guidance:**
    *   Enforce entitlements **server-side** (or via Play Billing purchase token verification on the server) and treat the client as untrusted.
    *   If offline state must exist:
        *   Store only **opaque, short-lived** entitlement tokens and validate them cryptographically (e.g., signed by backend) before granting access.
        *   Use **integrity protection** for local state (HMAC with a key in Android Keystore; detect tampering).
        *   Avoid designing unlock logic around simple boolean/string flags (e.g., `"UNLOCKED"`) that can be trivially flipped.

